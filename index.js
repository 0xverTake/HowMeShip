require('dotenv').config();
const { Client, Collection, GatewayIntentBits, REST, Routes } = require('discord.js');
const fs = require('fs');
const path = require('path');
const cron = require('node-cron');

// Importation des modules
const Database = require('./config/database');
const UpgradePriceService = require('./services/upgradePriceService');

// Cr√©ation du client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds
    ]
});

// Collection pour stocker les commandes
client.commands = new Collection();

// Variables globales
let database;
let upgradePriceService;

// Variables pour les statistiques du bot
let botStats = {
    status: 'starting',
    uptime: 0,
    memory: 0,
    cpu: 0,
    lastRestart: new Date(),
    alertsActive: 0,
    upgradesCalculated: 0,
    cacheHitRate: '0%'
};

// Fonction pour charger les commandes
function loadCommands() {
    const commandsPath = path.join(__dirname, 'commands');
    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);
        const command = require(filePath);
        
        if ('data' in command && 'execute' in command) {
            client.commands.set(command.data.name, command);
            console.log(`‚úÖ Commande charg√©e: ${command.data.name}`);
        } else {
            console.log(`‚ö†Ô∏è Commande ignor√©e (structure invalide): ${file}`);
        }
    }
}

// Fonction pour enregistrer les commandes slash
async function deployCommands() {
    const commands = [];
    
    client.commands.forEach(command => {
        commands.push(command.data.toJSON());
    });

    const rest = new REST().setToken(process.env.DISCORD_TOKEN);

    try {
        console.log('üîÑ D√©ploiement des commandes slash...');
        
        await rest.put(
            Routes.applicationCommands(client.user.id),
            { body: commands }
        );

        console.log('‚úÖ Commandes slash d√©ploy√©es avec succ√®s!');
    } catch (error) {
        console.error('‚ùå Erreur lors du d√©ploiement des commandes:', error);
    }
}

// Fonction d'initialisation des services
function initializeServices() {
    upgradePriceService = new UpgradePriceService();
    console.log('‚úÖ Services d\'alertes d\'upgrades initialis√©s');
}

// Fonction de v√©rification des donn√©es UEX Corp
async function checkUEXData() {
    console.log('üîÑ V√©rification des donn√©es UEX Corp...');
    
    try {
        const shipCount = await database.getShipCount();
        console.log(`üìä Nombre de vaisseaux en base: ${shipCount}`);
        
        if (shipCount === 0) {
            console.log('‚ö†Ô∏è Base de donn√©es vide - Veuillez ex√©cuter la migration UEX Corp');
            console.log('üí° Utilisez: node scripts/migrate-uex-data.js');
        } else {
            console.log('‚úÖ Donn√©es UEX Corp disponibles');
        }
        
        return shipCount > 0;
    } catch (error) {
        console.error('‚ùå Erreur lors de la v√©rification des donn√©es:', error.message);
        return false;
    }
}

// √âv√©nement: Bot pr√™t
client.once('ready', async () => {
    console.log(`ü§ñ Bot connect√© en tant que ${client.user.tag}`);
    
    // D√©ployer les commandes slash
    await deployCommands();
    
    // D√©finir le statut du bot
    client.user.setActivity('Star Citizen Upgrades | UEX Corp Data', { type: 'WATCHING' });
    
    // V√©rifier les donn√©es UEX Corp
    const hasData = await checkUEXData();
    
    if (hasData) {
        // D√©marrer le service d'alertes d'upgrades
        console.log('üîÑ D√©marrage du service d\'alertes d\'upgrades...');
        await upgradePriceService.startAlertService(client, 30); // V√©rification toutes les 30 minutes
    } else {
        console.log('‚ö†Ô∏è Service d\'alertes non d√©marr√© - Donn√©es manquantes');
    }
    
    // Initialiser les statistiques du bot
    updateBotStatistics();
    
    // Mettre √† jour les statistiques toutes les minutes
    setInterval(updateBotStatistics, 60000);
    
    console.log('üåê Interface web disponible sur http://localhost:3001/dashboard');
});

// √âv√©nement: Interaction (commandes slash et boutons)
client.on('interactionCreate', async interaction => {
    // Gestion de l'autocompl√©tion
    if (interaction.isAutocomplete()) {
        const command = client.commands.get(interaction.commandName);
        
        if (!command || !command.autocomplete) return;
        
        try {
            await command.autocomplete(interaction, database);
        } catch (error) {
            console.error('Erreur lors de l\'autocompl√©tion:', error);
        }
        return;
    }
    
    // Gestion des menus de s√©lection
    if (interaction.isStringSelectMenu()) {
        try {
            // Essayer de trouver une commande qui peut g√©rer ce menu
            for (const command of client.commands.values()) {
                if (command.handleSelectMenu && await command.handleSelectMenu(interaction)) {
                    return; // Menu g√©r√© avec succ√®s
                }
            }
            
            // Si aucune commande n'a g√©r√© le menu
            console.log(`Menu non g√©r√©: ${interaction.customId}`);
            
        } catch (error) {
            console.error('Erreur lors de la gestion du menu:', error);
            
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({
                    content: '‚ùå Erreur lors du traitement de cette s√©lection.',
                    ephemeral: true
                });
            }
        }
        return;
    }
    
    // Gestion des boutons
    if (interaction.isButton()) {
        try {
            // Essayer de trouver une commande qui peut g√©rer ce bouton
            for (const command of client.commands.values()) {
                if (command.handleButton && await command.handleButton(interaction)) {
                    return; // Bouton g√©r√© avec succ√®s
                }
            }
            
            // Si aucune commande n'a g√©r√© le bouton
            console.log(`Bouton non g√©r√©: ${interaction.customId}`);
            
        } catch (error) {
            console.error('Erreur lors de la gestion du bouton:', error);
            
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({
                    content: '‚ùå Erreur lors du traitement de cette action.',
                    ephemeral: true
                });
            }
        }
        return;
    }
    
    // Gestion des commandes slash
    if (!interaction.isChatInputCommand()) return;

    const command = client.commands.get(interaction.commandName);

    if (!command) {
        console.error(`Commande inconnue: ${interaction.commandName}`);
        return;
    }

    try {
        await command.execute(interaction, database);
        
        // Incr√©menter le compteur d'upgrades pour certaines commandes
        if (['upgrade', 'compare', 'ship'].includes(interaction.commandName)) {
            incrementUpgradeCount();
        }
        
    } catch (error) {
        console.error('Erreur lors de l\'ex√©cution de la commande:', error);
        
        const errorMessage = {
            content: '‚ùå Une erreur est survenue lors de l\'ex√©cution de cette commande.',
            ephemeral: true
        };
        
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp(errorMessage);
        } else {
            await interaction.reply(errorMessage);
        }
    }
});

// √âv√©nement: Erreur
client.on('error', error => {
    console.error('Erreur Discord.js:', error);
});

// Gestion des erreurs non captur√©es
process.on('unhandledRejection', error => {
    console.error('Erreur non g√©r√©e:', error);
});

process.on('uncaughtException', error => {
    console.error('Exception non captur√©e:', error);
    process.exit(1);
});

// Fonction principale d'initialisation
async function main() {
    try {
        console.log('üöÄ D√©marrage du bot Star Citizen Upgrade Navigator...');
        
        // V√©rifier les variables d'environnement
        if (!process.env.DISCORD_TOKEN) {
            throw new Error('DISCORD_TOKEN manquant dans les variables d\'environnement');
        }
        
        // Initialiser la base de donn√©es
        console.log('üîÑ Initialisation de la base de donn√©es...');
        database = new Database();
        await database.init();
        
        // Charger les commandes
        console.log('üîÑ Chargement des commandes...');
        loadCommands();
        
        // Initialiser les services
        console.log('üîÑ Initialisation des services...');
        initializeServices();
        
        // Programmer les v√©rifications p√©riodiques des alertes (toutes les heures)
        console.log('‚è∞ Programmation des v√©rifications d\'alertes...');
        
        cron.schedule('0 * * * *', async () => {
            console.log('‚è∞ V√©rification automatique des alertes d\'upgrades');
            if (upgradePriceService) {
                await upgradePriceService.checkAlerts(client);
            }
        });
        
        // Connecter le bot Discord
        console.log('üîÑ Connexion √† Discord...');
        await client.login(process.env.DISCORD_TOKEN);
        
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'initialisation:', error);
        process.exit(1);
    }
}

// Fonction pour mettre √† jour les statistiques du bot
function updateBotStatistics() {
    const now = Date.now();
    const memUsage = process.memoryUsage();
    
    botStats = {
        status: 'online',
        uptime: Math.floor((now - client.readyTimestamp) / 1000),
        memory: Math.round(memUsage.heapUsed / 1024 / 1024), // MB
        cpu: process.cpuUsage(),
        lastRestart: botStats.lastRestart,
        alertsActive: botStats.alertsActive,
        upgradesCalculated: botStats.upgradesCalculated,
        cacheHitRate: botStats.cacheHitRate
    };
}

// Fonction pour incr√©menter le compteur d'upgrades
function incrementUpgradeCount() {
    botStats.upgradesCalculated++;
    updateBotStatistics();
}

// Fonction pour mettre √† jour le nombre d'alertes actives
function updateAlertCount(count) {
    botStats.alertsActive = count;
    updateBotStatistics();
}

// Fonction pour mettre √† jour le taux de cache hit
function updateCacheHitRate(rate) {
    botStats.cacheHitRate = rate;
    updateBotStatistics();
}

// Gestion de l'arr√™t propre
process.on('SIGINT', () => {
    console.log('\nüîÑ Arr√™t du bot...');
    
    if (database) {
        database.close();
    }
    
    client.destroy();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüîÑ Arr√™t du bot (SIGTERM)...');
    
    if (database) {
        database.close();
    }
    
    client.destroy();
    process.exit(0);
});

// D√©marrer l'application
main();
